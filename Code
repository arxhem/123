import random
import time

list1 = [0, 1]
count =0 

n = int(input("Enter n: ")) 
total = n*n

#initalizing list
arr = [[0 for _ in range(n)] for _ in range(n)]

#randomly setting 1 or 0 to 2d list
for i in range(n):
    for j in range(n):
        arr[i][j] = random.choice(list1)

print(arr)

#logic
start_time = time.time()

for i in range(n):
    for j in range(n):
        if(arr[i][j]==1):
            
            arr[i][j]=0
            print("room cleaned is", i, j)
            count+=1

end_time = time.time()

print("the number of rooms cleaned is", count)

print("the room cleaning efficiencyis", (count/total)*100)
            
execution_time = end_time - start_time
print(f"Execution time: {execution_time:.6f} seconds")


--------------------------------------------------------------------------------------------------------------------------



#package importing
import os

#initialising variables
turn = 'X'
win = False
spaces = 9

#printing the representation of tic tac toe board

def draw(board):
    for i in range(6, -1, -3):
        print(' ' + board[i] + '|' +
            board[i+1] + '|' + board[i+2])
        
#to take inputs as players
def takeinput(board, spaces, turn):
    pos = -1
    print(turn + "'s turn:")
    while pos == -1:
        try:
            print("Pick position 1-9:")
            pos = int(input())
            if(pos < 1 or pos > 9):
                pos = -1
            elif board[pos - 1] != ' ':
                pos = -1
        except:
            print("enter a valid position")

    spaces -= 1
    board [pos - 1] = turn

    if turn == 'X':
        turn = 'O'
    else:
        turn = 'X'
    return board, spaces, turn

#function to check the utility function of who won or if its a draw
def checkwin(board):

#optimal way
    for i in range(0, 3):
        r = i*3
        if board[r] != ' ':
            if board[r] == board[r+1] and board[r+1] == board[r+2]:
                return board[r]
            
#this to ckeck colums
    if board[i] != ' ':
        if board[i] == board[i+3] and board[i] == board[i+6]:
            return board[i]
        
#this to ckeck diagonals
    if board[0] != ' ':
        if (board[0] == board[4] and board[4] == board[8]):
            return board[0]
    if board[2] != ' ':
        if (board[2] == board[4] and board[4] == board[6]):
            return board[2]
    return 0


board = [' ']*9
while not win and spaces:
    draw(board)
    board, spaces, turn = takeinput(board, spaces, turn)
    win = checkwin(board)
    os.system('cls')


draw(board)
if not win and not spaces:
    print("draw")
elif win:
    print(f'{win} wins')
    input()


----------------------------------------------------------------------------------------------------------------------------

import numpy as np

theta = 1
epoch = 3

class Perceptron(object):
    def __init__(self, input_size, learning_rate=0.2):
        self.learning_rate = learning_rate
        self.weights = np.zeros(input_size + 1)  # zero init for weights and bias

    def predict(self, x):
        return (np.dot(x, self.weights[1:]) + self.weights[0])  # X.W + B

    def train(self, x, y, weights):
        for inputs, label in zip(x, y):
            net_in = self.predict(inputs)
            if net_in > theta:
                y_out = 1
            elif net_in < -theta:
                y_out = -1
            else:
                y_out = 0

            if y_out != label:  # updating the net on incorrect prediction
                self.weights[1:] += self.learning_rate * label * inputs  # W = alpha * Y * X
                self.weights[0] += self.learning_rate * label  # B = alpha * Y
                print(inputs, net_in, label, y_out, self.weights)

if __name__ == "__main__":
    x = []
    x.append(np.array([1, 1]))
    x.append(np.array([1, -1]))
    x.append(np.array([-1, 1]))
    x.append(np.array([-1, -1]))
    y = np.array([1, -1, -1, -1])
    
    perceptron = Perceptron(2)
    
    for i in range(epoch):
        print("Epoch", i)
        print("X1 X2 ", " Net ", " T ", " Y ", " B Weights")
        
        weights = perceptron.weights
        print("Initial Weights", weights)
        
        perceptron.train(x, y, weights)
 -------------------------------------------------------------------------------------------------------------------------------------

def mcculloch_pitts(inputs, weights, threshold):
    """McCulloch-Pitts neuron model."""
    # Ensure the number of inputs matches the number of weights
    assert len(inputs) == len(weights), "Number of inputs must match the number of weights"
    # Calculate the weighted sum of inputs
    weighted_sum = sum(x * w for x, w in zip(inputs, weights))
    # Apply the threshold function
    output = 1 if weighted_sum >= threshold else 0
    return output

def test_logic_gate(logic_gate):
    """Test a logic gate using McCulloch-Pitts neuron."""
    print(f"Testing {logic_gate} gate:")
    if logic_gate == "AND":
        # AND gate
        inputs = [(0, 0), (0, 1), (1, 0), (1, 1)]
        weights = (1, 1)
        threshold = 2
    elif logic_gate == "OR":
        # OR gate
        inputs = [(0, 0), (0, 1), (1, 0), (1, 1)]
        weights = (1, 1)
        threshold = 1
    elif logic_gate == "XOR":
        # XOR gate (requires a combination of AND, OR, and NOT gates)
        inputs = [(0, 0), (0, 1), (1, 0), (1, 1)]
        weights_andnot = (1, -1)
        weights_andnott = (-1, 1)
        weights_or = (1, 1)
        threshold = 1
        for input_pair in inputs:
            input1, input2 = input_pair
            # XOR is implemented using a combination of AND, OR, and NOT
            and_1 = mcculloch_pitts(input_pair, weights_andnot, threshold)
            and_2 = mcculloch_pitts(input_pair, weights_andnott, threshold)
            xor_result = mcculloch_pitts((and_1, and_2), weights_or, threshold)
            print(f"{input_pair}: {xor_result}")
        return
    elif logic_gate == "AND NOT":
        # AND NOT gate
        inputs = [(0, 0), (0, 1), (1, 0), (1, 1)]
        weights = (1, -1)
        threshold = 1
    else:
        print("Invalid logic gate.")
        return

    # Test the logic gate
    for input_pair in inputs:
        result = mcculloch_pitts(input_pair, weights, threshold)
        print(f"{input_pair}: {result}")

# Example usage:
test_logic_gate("AND")
test_logic_gate("OR")
test_logic_gate("XOR")
test_logic_gate("AND NOT")

-----------------------------------------------------------------------------------------------------------------------------------


import os
turn = 'X'
win = False
spaces = 9

def draw(board):
    for i in range(6, -1, -3):
        print(' ' + board[i] + '|' + board[i+1] + '|' + board[i+2])
    print()
        
def takeinput(board, spaces, turn):
    pos = -1
    print(turn + "'s turn:")
    while pos == -1:
        try:
            # print("Pick position 1-9:")
            # pos = int(input())
            pos = int(input("Pick position 1-9: "))
            if(pos < 1 or pos > 9):
                pos = -1
            elif board[pos - 1] != ' ':
                pos = -1
        except:
            print("Enter a valid position")
    spaces -= 1
    board [pos - 1] = turn
    if turn == 'X':
        turn = 'O'
    else:
        turn = 'X'
    return board, spaces, turn

def checkwin(board):
    # could probably make this better
    for i in range(0, 3):
        r = i*3
        if board[r] != ' ':
            if board[r] == board[r+1] and board[r+1] == board[r+2]:
                return board[r]

    # columns
    if board[i] != ' ':
        if board[i] == board[i+3] and board[i] == board[i+6]:
            return board[i]

    # diagonals
    if board[0] != ' ':
        if (board[0] == board[4] and board[4] == board[8]):
            return board[0]

    if board[2] != ' ':
        if (board[2] == board[4] and board[4] == board[6]):
            return board[2]
    return 0

board = [' ']*9
while not win and spaces:
    draw(board)
    board, spaces, turn = takeinput(board, spaces, turn)
    win = checkwin(board)
    os.system('cls')
draw(board)
if not win and not spaces:
    print("draw")
elif win:
    print(f'{win} wins!') 

---------------------------------------------------------------------------------------------------------------------------

maximum, minimum=1000,-1000
def fun_alphabeta(d,node,maxp,v,A,B):
    if d==3:
        return v[node]
    if maxp:
        best =minimum
        for i in range(0,2):
            value=fun_alphabeta(d+1,node*2+i,False,v,A,B)
            best=max(best,value)
            A=max(A,best)
            if B<=A:
                break
        return best
    else:
        best=maximum
        for i in range(0,2):
            value=fun_alphabeta(d+1,node*2+i,True,v,A,B)
            best=min(best,value)
            A=min(A,best)
            if B<=A:
                break
            return best
scr=[]
x= int(input("Enter total number of leaf node:"))
for i in range(x):
    y=int(input("Enter node value"))
    scr.append(y)
d=int(input("Enter depth value:"))
node=int(input("Enter node value:"))
print("The optimal value is:",fun_alphabeta(d,node,True,scr,minimum,maximum))
